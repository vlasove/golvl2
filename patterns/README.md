
## Детально о каждом паттерне

### 1. Фасад
**Фасад** - это структурный паттерн проектирования, который предоставляет простой интерфейс к сложной системе классов, библиотеке или фреймворку.

**Фасад** - простой интерфейс для работы со сложной подсистемой (содержит много классов и проч)

**Фасад полезен**, если вы используете какую-то сложную библиотеку со множеством подвижных частей, но вам нужна только часть её возможностей.

**Аналогия из жизни** - заказ по телефону. Оператор - это `фасад` ко всему службам и отделам магазина (простой интерфейс).

#### 1.1 Применимость
* Когда нужно предоставить простой или урезанный интерфейс к сложной подсистеме.
* Когда нужно разложить подсистему на отдельные слои.

#### 1.2 Преимущества
* Изолирует клиентов от компонентов сложной подсистемы (клиенту не надо знать, что там и как внутри устрено)

#### 1.3 Недостатки
* Фасад рискует стать `божественным объектом`, привязанным ко всем классам программы. (БО - объект, который хранит в себе слишком много всего или делает слишком много всего).


### 2. Строитель
**Строитель** - это порождающий паттерн проектирования, который позволяет создавать сложные объекты пошагово. 

**Строитель** - это способ пошаговой сборки объекта известной сложности. Часто может существовать несколько строителей, которые выполняют свою работу (строят) по-разному. Для их управления может быть полезен **директор**. Строитель возвращает **продукт**.

**Продукт** - результат работы конкретного **строителя**.

**Директор** - объект, который заставляет работать строителей, но директор **НЕ ЗНАЕТ** про готовый продукт (не зависит от конкретной реализации строителя и продукта) 

**Строитель полезен** - когда итоговый объект требует достаточно обширной иницилазиации (замена телескопическому конструктору)

#### 2.1 Применимость
* Когда нужно избавиться от телескопического конструктора.
* Когда код должен создавать разные представления какого-то объекта. Например, внедорожник и спортивная машина.
* Когда нужно собирать сложные составные объекты (например рекурсивное создание деревьев)

#### 2.2 Преимущества
* Позволяет создавать продукты пошагово.
* Позволяет использовать один и тот же код для создания различных продуктов.
* Изолирует сложный код сборки продукта от его основной бизнес-логики.

#### 2.3 Недостатки
* Усложняет код программы из-за введения дополнительных классов.
* Клиент будет привязан к конкретным классам строителей, так как в интерфейсе директора может не быть метода получения результата.



### 3. Посетитель
**Посетитель** - это поведенческий паттерн проектирования, который позволяет добавлять в программу новые операции, не изменяя классы объектов, над которыми эти операции могут выполняться.

**Посетитель** - это способ добавления нового функционала существующим классам (объектам) с минимумом изменений исходных классов. Добавление нового функционала сводится к реализации класса **посетителя** и, возможно, небольшого изменения исходных классов, направленных на взаимодействие с посетитлем.

**Аналогия из жизни** - страховой агент, который `посещает` разные организации. Для каждой организации `посетитель` приготовил специальное предложение. (у каждого типа посетитель выдает новый функционал, необходимый для этого типа).

#### 3.1 Применимость
* Когда вам нужно выполнить какую-то операцию над всеми элементами сложной структуры объектов, например, деревом.
* Когда над объектами сложной структуры объектов надо выполнять некоторые не связанные между собой операции, но вы не хотите «засорять» классы такими операциями.
* Когда новое поведение имеет смысл только для некоторых классов из существующей иерархии.

#### 3.2 Преимущества
* Упрощает добавление операций, работающих со сложными структурами объектов.
* Объединяет родственные операции в одном классе.
* Посетитель может накапливать состояние при обходе структуры элементов.
#### 3.3 Недостатки
* Паттерн не оправдан, если иерархия элементов часто меняется.
* Может привести к нарушению инкапсуляции элементов (если посетителям нужен доступ к приватным полям).


### 4. Команда
**Команда** - это поведенческий паттерн проектирования, который превращает запросы в объекты, позволяя передавать их как аргументы при вызове методов, ставить запросы в очередь, логировать их, а также поддерживать отмену операций.

**Команда** — это поведенческий паттерн, позволяющий заворачивать запросы или простые операции в отдельные объекты.

**Команда** - по сути, это прослойка между пользовательским интерфейсом и бизнес-логикой.

**Аналогия из жизни** - заказ в ресторане. Посетитель (отправитель) говорит официанту (команде), что ему хотелось бы заказать. Далее официант (команда) относит листок с заказом поавру (получатель). Идея в том, что отправитель не взаимодействует напрямую с получателем. Вся необходимая информация для получается содержится в заказе.

#### 4.1 Применимость
* Когда вы хотите параметризовать объекты выполняемым действием.
* Когда вы хотите ставить операции в очередь, выполнять их по расписанию или передавать по сети.
* Когда вам нужна операция отмены.

#### 4.2 Преимущества
* Убирает прямую зависимость между объектами, вызывающими операции, и объектами, которые их непосредственно выполняют.
* Позволяет реализовать простую отмену и повтор операций.
* Позволяет реализовать отложенный запуск операций.
* Позволяет собирать сложные команды из простых.
* Реализует принцип открытости/закрытости.

#### 4.3 Недостатки
* Усложняет код программы из-за введения множества дополнительных классов.

### 5. Цепочка обязанностей
**Цепочка обязанностей** — это поведенческий паттерн проектирования, который позволяет передавать запросы последовательно по цепочке обработчиков. Каждый последующий обработчик решает, может ли он обработать запрос сам и стоит ли передавать запрос дальше по цепи.

**Аналогия из жизни** - звонок в сервисный центр. Сначала отвечает автоответчик с 10 стандартными способами решения проблемы (первое звено цепи). Если задача не решена - дальше разговор с сотрудником колл-центра (второе звено цепи). Если задача не решена - идем дальше - звонок сервисному инженеру (третье звено цепи) и т.д.

#### 5.1 Применимость
* Когда программа должна обрабатывать разнообразные запросы несколькими способами, но заранее неизвестно, какие конкретно запросы будут приходить и какие обработчики для них понадобятся.
* Когда важно, чтобы обработчики выполнялись один за другим в строгом порядке.
* Когда набор объектов, способных обработать запрос, должен задаваться динамически.

#### 5.2 Преимущества
* Уменьшает зависимость между клиентом и обработчиками.
* Реализует принцип единственной обязанности.
* Реализует принцип открытости/закрытости.

#### 5.3 Недостатки
* Запрос может остаться никем не обработанным.


### 6. Фабричный метод
**Фабричный метод** — это порождающий паттерн проектирования, который определяет общий интерфейс для создания объектов в суперклассе, позволяя подклассам изменять тип создаваемых объектов.

#### 6.1 Применимость
* Когда заранее неизвестны типы и зависимости объектов, с которыми должен работать ваш код.
* Когда вы хотите дать возможность пользователям расширять части вашего фреймворка или библиотеки.
* Когда вы хотите экономить системные ресурсы, повторно используя уже созданные объекты, вместо порождения новых.

#### 6.2 Преимущества
* Избавляет класс от привязки к конкретным классам продуктов.
* Выделяет код производства продуктов в одно место, упрощая поддержку кода.
* Упрощает добавление новых продуктов в программу.
* Реализует принцип открытости/закрытости.


#### 6.3 Недостатки
* Может привести к созданию больших параллельных иерархий классов, так как для каждого класса продукта надо создать свой подкласс создателя.


### 7. Стратегия
**Стратегия** — это поведенческий паттерн проектирования, который определяет семейство схожих алгоритмов и помещает каждый из них в собственный класс, после чего алгоритмы можно взаимозаменять прямо во время исполнения программы.

#### 7.1 Применимость
* Когда вам нужно использовать разные вариации какого-то алгоритма внутри одного объекта.
* Когда у вас есть множество похожих классов, отличающихся только некоторым поведением.
* Когда вы не хотите обнажать детали реализации алгоритмов для других классов.
* Когда различные вариации алгоритмов реализованы в виде развесистого условного оператора. Каждая ветка такого оператора представляет собой вариацию алгоритма.

#### 7.2 Преимущества
* Горячая замена алгоритмов на лету.
* Изолирует код и данные алгоритмов от остальных классов.
* Уход от наследования к делегированию.
* Реализует принцип открытости/закрытости.

#### 7.3 Недостатки
* Усложняет программу за счёт дополнительных классов.
* Клиент должен знать, в чём состоит разница между стратегиями, чтобы выбрать подходящую.

### 8. Состояние
**Состояние** — это поведенческий паттерн проектирования, который позволяет объектам менять поведение в зависимости от своего состояния. Извне создаётся впечатление, что изменился класс объекта.

#### 8.1 Применимость
* Когда у вас есть объект, поведение которого кардинально меняется в зависимости от внутреннего состояния, причём типов состояний много, и их код часто меняется.
* Когда код класса содержит множество больших, похожих друг на друга, условных операторов, которые выбирают поведения в зависимости от текущих значений полей класса.
* Когда вы сознательно используете табличную машину состояний, построенную на условных операторах, но вынуждены мириться с дублированием кода для похожих состояний и переходов.


#### 8.2 Преимущества
* Избавляет от множества больших условных операторов машины состояний.
* Концентрирует в одном месте код, связанный с определённым состоянием.
* Упрощает код контекста.

#### 8.3 Недостатки
* Может неоправданно усложнить код, если состояний мало и они редко меняются.